#FPC сегментация

«Сегментация FPC» заключается в том, что кэшируются несколько версий страницы. Затем для любого запроса правильная версия этой страницы извлекается из кеша и доставляется клиенту.
Поскольку FPC не обязательно является частью приложения PHP, среду приложения нельзя использовать для принятия решения, какая версия данной страницы будет доставлена из кеша.

Может использоваться только информация в HTTP-запросе, то есть URI, параметры запроса, HTTP-заголовки, включая файлы cookie, и некоторая базовая информация транспортного уровня (в основном, IP-адрес клиента).
Примером использования сегментации FPC может быть модуль, который позволяет посетителям настраивать магазин на основе своих цветовых предпочтений. Товары отображаются в предпочтительной для посетителей цветовой палитре.
Это означает, что любой URL-адрес продукта будет содержать другой HTML-код в зависимости от настроек посетителей.
FPC больше не может использовать только URL-адрес для определения записи кеша для выборки, ему также необходимо учитывать предпочтения посетителей.
Сохранение предпочтения цвета в сеансе посетителя сделает его доступным для PHP и, таким образом, может использоваться со встроенным FPC, но этого недостаточно для Varnish.
Вместо этого предпочтения посетителей должны храниться в виде файлов cookie.

####Как это работает.

Когда Magento генерирует страницу, ответ может быть дополнен метаинформацией о том, можно ли и как ее кэшировать.
Это делается через общий экземпляр \Magento\Framework\App\Http\Context.

Когда Magento генерирует ответ страницы, этот объект отвечает за создание значения cookie, которое определяет вариант страницы.

Шаги:

1.Magento\Framework\App\Bootstrap::run()

2.Magento\Framework\App\Response\Http::sendResponse()

3.Magento\PageCache\Model\App\Response\HttpPlugin::beforeSendResponse()

4.Magento\Framework\App\Response\Http::sendVary()

```
public function sendVary()
{
    $varyString = $this->context->getVaryString();
    if ($varyString) {
        $sensitiveCookMetadata = $this->cookieMetadataFactory->createSensitiveCookieMetadata()->setPath('/');
        $this->cookieManager->setSensitiveCookie(self::COOKIE_VARY_STRING, $varyString, $sensitiveCookMetadata);
    } elseif ($this->request->get(self::COOKIE_VARY_STRING)) {
        $cookieMetadata = $this->cookieMetadataFactory->createSensitiveCookieMetadata()->setPath('/');
        $this->cookieManager->deleteCookie(self::COOKIE_VARY_STRING, $cookieMetadata);
    }
}
```

Эта строка варианта также используется при генерации идентификатора кэша для встроенного кэша,
и такая же логика также присутствует в конфигурации VCL. Это означает, что всякий раз, когда \Magento\Framework\App\Http\Context::getVaryString() возвращает другое значение,
будет использоваться новая запись кеша для страницы.

####Как создать новый сегмент

Строка, которую возвращает метод Http\Context::getVaryString(), представляет собой хэш нескольких фрагментов данных.
В нативной установке Magento FPC сегментирован по группе кастомеров, сторвью, валюте и статусу кастомера с точки зрения логина.
Мы, как разработчики, можем добавлять дополнительные данные к значениям,
которые используются в качестве источника хэша, используя Http\Context::setValue($name, $value, $default). Где:

- $name - это строковый идентификатор, который однозначно идентифицирует наш сегмент кеша (например, COLOR_PREFERENCE).

- $value - это значение для созданной страницы (например, светло-зеленый).
  Значение не ограничивается строками, но оно должно быть сериализуемым с помощью json_encode ().

- $default - это значение, которое следует принимать для новых посетителей, то есть всех гостей.

В документации для разработчиков рекомендуемый способ установки дополнительных значений в Http\Context - через плагин beforeGetVaryString().

Но есть вариант что будет применен один из DepersonalizePlugin, который удалит данные сессии текущего пользователя.

Вариант установки значения контекста для дальнейшего рендеринга страницы с учетом ее сегментации:

1. создать UnDepersonalizePlugin, который будет вызываться перед и после вызова метода Magento\Framework\View\Layout::generateXml и будет проверять если персонализация в дальнейшем будет, то сохранить локально значение переменной, ктоорая будет влиять на дальнейшее кэширование всей страницы.
   После этот плагин после генерации xml должен восстановить сохраненную переменную в текущую сессию.

2. создать плагин, который будет отрабатывать, например, после вызова экшена текущей страницы. Метов плагина afterExecute должен добавить в контекст сохраненную в текущей сессии переменную и тем самым добавить возможность сегментации страницы по еще одному признаку

В результате на стороне пользователя будет установлена кука X-Magento-Vary с идентификатором текущей версии кэша в FPC.

####Недостатки сегментирования

Одним из недостатков является то, что при первом заходе на страницу, которая сегментирована не по наривному принципу самой Магенто, X-Magento-Vary кука не будет установлена у клиента и поэтому есть 2 варианта как отрендерить страницу:

1. пройти мимо FPC и отрендерить бэкэндом контент тем самым пойти против главных принципов кэширования в FPC
2. отдать дэфолтную закэшированную страницу из FPC, которая отдается всем клиентам, у которых не установлена кука, для конкретизации сегментирования.

Во всех этих случаях необходимо продумывать - как установить текущее значение для куки X-Magento-Vary на стороне клиента.
Т.к. она устанавливается только при HTTP POST или PUT запросах. А все 2 описанных варианта - это GET запрос.
Таким образом необходимо Javacript-ом первоначально рендерить страницу для получения этой куки от сервера. Также необходимо продумывать, как рендерить различные страницы сайта, если на одной странице необходима сегментация кэша в FPC, а для другой - нет.
Происходит каждый раз пересчет значения куки X-Magento-Vary на бэкенде при переходе с одной страницы на другую. И как видно, что эффективноесть применения сегментации в данном случае стремится к нулю.