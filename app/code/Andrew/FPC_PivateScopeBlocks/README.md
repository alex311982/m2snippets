#Рендеринг кэшируемой страницы с приватным контентом используя приватные блоки в скоупе

Magento 2 включает улучшенную встроенную поддержку кеширования. Однако разработчики решили не использовать ESI для частного контента
(контента, специфичного для одного пользователя, например как его имя).
Magento 2 действительно использует ESI в некоторых случаях, но для другого варианта использования.
Когда вы видите ESI в Magento 2, это не для частного (некэшируемого) контента. Это для расшаренного контента.

Вместо этого Magento 2 рендерит (как правило) страницу, заполненную на 95%,
а затем полагается на JavaScript и AJAX для вставки последних 5% пользовательского контента на страницу.
Например, в отрендеренной изначально странице имя пользователя должно оставаться пустым.
У этого подхода есть несколько преимуществ:

1. Один вызов AJAX может получить весь личный пользовательский контент вместо одного запроса на заменяемую часть страницы (как это делается с ESI). Это может уменьшить количество HTTP-запросов.
2. Частный контент также кэшируется веб-браузером. Например, имя клиента вряд ли изменится, так почему бы не сохранить его в кеше веб-браузера и избежать будущих вызовов AJAX?
   Возникает вопрос, как обновить частный контент, кэшированный в веб-браузере (например, если покупатель добавляет товар в свою корзину, то «количество товаров в корзине» изменится).
   Это решается путем очистки кеша веб-браузера каждый раз при выполнении запроса HTTP POST.
   HTTP POST - это то, как вы отправляете форму или выполняете какие-либо действия на сайте.
   Поэтому, если пользователь просматривает страницы сайта, он просто выполняет запросы GET, которые можно полностью кэшировать.
   Если они выполняют POST (например, нажимают кнопку, чтобы добавить элемент в свою корзину), то кеш в веб-браузере будет очищен,
   и будет выполнен вызов AJAX для получения обновленной копии частного содержимого (например, такие сведения, как количество товаров в корзине будет обновлено).


Версионирование частного (приватного) контента.

Частный контент, который хранится в локальном хранилище браузера, использует куки private_content_version для хранения текущей версии версии приватного контента.

Управление версиями работает следующим образом:

1. Пользователь выполняет какое-либо действие, например добавление в корзину, что приводит к отправке запроса POST или PUT в приложение Magento.
2. Сервер генерирует cookie-файл private_content_version для этого пользователя и возвращает ответ браузеру.
3. JavaScript видит наличие файла cookie private_content_version - означающее, что на странице присутствует частный контент, поэтому он отправляет запрос AJAX на сервер Magento для получения
   текущего частного контента.
4. Ответ сервера кэшируется в локальном хранилище браузера.
   Последующие запросы с той же версией данных извлекаются из локального хранилища.

5. Любые последующие HTTP-запрос POST или PUT изменяет значение private_content_version и приводит к кэшированию обновленного приватного контента браузером.

Хронология работы механизма кэширования используя приватные блоки в скоупе:

- Магенто удаляет из DAO сессионные данные, чтобы они не могли быть использованы при рендеринге страницы.
  Для этого необходимо создать или воспользоваться уже существующими плагинами для персонализации данных.
  Например, есть плагин в /vendor/magento/module-catalog/Model/Layout/DepersonalizePlugin.php, который очищает каталожные сессионные данные catalogSession и оставляет лишь не персональные данные.
  При необходимости можно создать подобный свой плагин и очищать например favorite products сессионный данные.

- Бэкэнд рендэрит полностью страницу с приватными блоками без сессионных данных.
  Для того чтобы блок стал приватным необходимо в блоке установить переменную _isScopePrivate равным true:
```
$this->_isScopePrivate = true;
```

- Отрендеренный приватный блок будет окружен маркером-комментарием <BLOCK>, чтобы в дальнейшем заключенный в него код был использован как плейсхолдер

- Вся страница закешируется в FPC

- И будет отправлена браузеру

Если кука private_content_version установлена, т.е. был в рамках текущей сессии осуществлен POST-запрос, то хронология продолжается:

- По проставленным маркерам Block JavaScript ищет приватные блоки

- Отсылается один для всех найденных блоков Ajax-запрос на /page_cache/block/render

- Т.к. это Ajax-запрос контролер не будет задействовать лэйаут, а значит - не будут вызваны патчи для удаления персональных данных из сессионного контейнера. Значит - все сессионные данные будут учавствовать в рендеренге ответа.

- Рендерится каждый приватный блок из запроса

- Отрендеренный контент каждого блока отправляется в ответе на Ajax-запрос

- Javascript замещает текущее содержимое блоков на отрендренное бэкэндом